# Hints — Tiled Matmul

You literally wrote this 5 times already. From your own error notes:
1. DRAW THE PICTURE FIRST
2. Don't confuse row/col naming
3. Don't vibe the shared memory indexing — work it out by hand

## Square version skeleton
```cuda
__shared__ float As[TILE_SIZE][TILE_SIZE];
__shared__ float Bs[TILE_SIZE][TILE_SIZE];

int row = blockIdx.y * TILE_SIZE + threadIdx.y;
int col = blockIdx.x * TILE_SIZE + threadIdx.x;

float val = 0.0f;
for (int t = 0; t < N / TILE_SIZE; t++) {
    As[threadIdx.y][threadIdx.x] = A[row * N + t * TILE_SIZE + threadIdx.x];
    Bs[threadIdx.y][threadIdx.x] = B[(t * TILE_SIZE + threadIdx.y) * N + col];
    __syncthreads();

    for (int k = 0; k < TILE_SIZE; k++)
        val += As[threadIdx.y][k] * Bs[k][threadIdx.x];
    __syncthreads();
}
C[row * N + col] = val;
```

## General version: add boundary checks
Load 0.0f when indices are out of bounds. Write only if row < M && col < N.
