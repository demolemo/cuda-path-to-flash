# Hints — 1D and 2D Block-Tiling

## 1D Block-Tiling key loop
```cuda
const int threadRow = threadIdx.x / BN;
const int threadCol = threadIdx.x % BN;

float results[TM] = {0.0f};

for (int bk = 0; bk < K; bk += BK) {
    // Load tiles collaboratively (each thread loads ~BM*BK/numThreads elements)
    // ...
    __syncthreads();
    
    for (int k = 0; k < BK; k++) {
        float bVal = Bs[k][threadCol];  // reused TM times!
        for (int i = 0; i < TM; i++) {
            results[i] += As[threadRow * TM + i][k] * bVal;
        }
    }
    __syncthreads();
}
```

## 2D Block-Tiling key loop
```cuda
float regA[TM], regB[TN];
float results[TM * TN] = {0.0f};

for (int k = 0; k < BK; k++) {
    for (int i = 0; i < TM; i++)
        regA[i] = As[threadRow * TM + i][k];
    for (int j = 0; j < TN; j++)
        regB[j] = Bs[k][threadCol * TN + j];
    
    // Outer product
    for (int i = 0; i < TM; i++)
        for (int j = 0; j < TN; j++)
            results[i * TN + j] += regA[i] * regB[j];
}
```

## Collaborative loading tip
With 256 threads loading BM×BK = 128×8 = 1024 floats:
each thread loads 1024/256 = 4 elements.
```cuda
int loadRow = threadIdx.x / BK;  // which row of the tile
int loadCol = threadIdx.x % BK;  // which col of the tile
// May need multiple loads if BM*BK > numThreads
```
