# Hints for Exercise 03 — Matrix Ops (2D Indexing)

## Hint 1: 2D thread indexing
```cuda
int row = blockIdx.y * blockDim.y + threadIdx.y;
int col = blockIdx.x * blockDim.x + threadIdx.x;
```
Note: `x` maps to columns, `y` maps to rows. This is the convention.

## Hint 2: Row-major layout
A 2D matrix stored in a 1D array:
```cuda
int idx = row * width + col;
```

## Hint 3: 2D grid configuration with dim3
```cuda
dim3 blockDim(16, 16);  // 16×16 = 256 threads per block
dim3 gridDim(
    (WIDTH  + blockDim.x - 1) / blockDim.x,   // blocks in x (columns)
    (HEIGHT + blockDim.y - 1) / blockDim.y     // blocks in y (rows)
);
```
**Careful**: dim3 constructor is `(x, y, z)` — x is the FIRST argument, which maps to columns.

## Hint 4: Bounds check
Both dimensions need checking:
```cuda
if (row < height && col < width) {
    // safe to access
}
```

## Hint 5: Variable name collision
Note that CUDA has built-in `blockDim` and `gridDim` variables. If you declare local variables with these names using `dim3`, they will shadow the built-ins inside kernels. This is fine in `main()` but be aware of it.
